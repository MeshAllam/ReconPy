import requests
import socket
import concurrent.futures
import re
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse, urlunparse, parse_qs, urlencode
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm
from pathlib import Path


class VulnerabilityScanner:
    def __init__(self, payload_file: str = "wordlists/xss_payloads.txt"):
        self.payloads = self._load_payloads(payload_file)
        self.session = requests.Session()
        self.session.headers.update({'User-Agent': 'ReconPy'})
        self.takeover_patterns = {
            'github.io': r'There isn\'t a GitHub Pages site here',
            'azurewebsites.net': r'Azure Web App - Error 404',
            'cloudfront.net': r'ERROR: The request could not be satisfied'
        }

    def _load_payloads(self, file_path: str) -> List[str]:
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"Payload file not found: {file_path}")
        with open(path, 'r') as f:
            return [line.strip() for line in f if line.strip()]

    def test_xss(self, url: str) -> Dict[str, List[str]]:
        results = {}
        parsed = urlparse(url)
        params = parse_qs(parsed.query)

        if not params:
            return {}

        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = []
            for param in params:
                for payload in self.payloads:
                    new_params = params.copy()
                    new_params[param] = [payload]
                    new_query = urlencode(new_params, doseq=True)
                    test_url = urlunparse(parsed._replace(query=new_query))
                    futures.append(executor.submit(self._check_xss, test_url, param, payload))

            for future in tqdm(concurrent.futures.as_completed(futures),
                             total=len(futures), desc="Testing XSS"):
                try:
                    result = future.result()
                    if result:
                        param, payload = result
                        results.setdefault(param, []).append(payload)
                except Exception:
                    continue

        return results

    def _check_xss(self, url: str, param: str, payload: str) -> Optional[Tuple[str, str]]:
        try:
            response = self.session.get(url, timeout=5)
            if payload in response.text:
                return (param, payload)
        except requests.RequestException:
            pass
        return None

    def check_subdomain_takeover(self, subdomain: str) -> bool:
        try:
            # Resolve DNS first
            socket.gethostbyname(subdomain)
            
            # Check for known vulnerable services
            for service, pattern in self.takeover_patterns.items():
                if subdomain.endswith(service):
                    try:
                        resp = requests.get(
                            f"http://{subdomain}",
                            timeout=5,
                            allow_redirects=False
                        )
                        if resp.status_code == 404 and re.search(pattern, resp.text):
                            return True
                    except requests.RequestException:
                        continue
            return False
        except socket.gaierror:
            return False
